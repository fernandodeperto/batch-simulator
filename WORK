1) answer questions
    - what partitions useful
    - comparison declared time vs real time
2) classes for objects
    - task
    - processor

3) scheduling algorithm

    -> real p_i, FCFS (then with backfilling)
        arrival time = 0
        tasks ordered (by real arrival time)

22-07

0) debugging

1)

fast scheduling

-> can we schedule with backfilling (without submit times)
10000 jobs on 10000 machines in less than 30 seconds ?

TODO:
	-> how about the use of kd-trees ?
	-> discussing with olivier to get traces
	-> modifying the oar perl scheduler to read data from traces instead of DB
	-> comparing fast scheduler and oar perl scheduler

2)

performance guarantee

why are both FCFS, FCFSC, backfilling good ?

-> can we find a characterization of the input such that
ratio (for each algorithm) to optimal > 2 => charact(input) > something

I tried to figure out different metrics to compare FCFS to backfilling but so far I have had no success.
The idea that I thought was the best one is to use a metric to determine how much "wasted space" there was
in the trace just by using the largest job in the segment of the trace as the width of that segment. The
problem is that the measure is not good enough, it's value does not make the ratio backfilling/FCFS better or worst.

3)

-> backfilling with contiguity (not best effort)

contiguity

a) backfilling contiguous best effort is better than backfilling (not contiguous best effort) ?

--> experimentally -> what traces to run on ?
--> proof ?

-> slurm / oar : what are they doing ?

I ran some experiments comparing the naive version of backfilling (just take the first processors available)
and the best effort version and it seems that they perform almost exactly the same. For reference, the experiments were numebered 109 to 112.

* b) best effort contiguous : how many jobs are contiguous ?? (almost all ???)

-> can we prove something ? (hint: yes)
-> run experiments and store percentage of contiguous jobs
-> look at worst cases -> is it high ? low ?
-> can you change slightly (by hand) the worst trace to make things worse ?

c) proof than contiguity constraint is not dramatically degrading cmax

-> looks tough

d) more strict topology constraints
-> assume 1 level of hierarchy
-> constraint/objective : each job uses a minimum number of clusters
-> see in backfilling best effort contiguity / contiguous backfilling : how many jobs do not have minimum # of clusters ?
-> if you enforce constraint -> how much is cmax degraded ?

-> maybe possibility for proofs (comparing the optimal cmax with or without additional constraint)
